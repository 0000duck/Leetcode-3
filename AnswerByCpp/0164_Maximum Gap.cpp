#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
/*
164. 最大间距

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。

示例 1:   输入: [3,6,9,1]       输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
示例 2:   输入: [10]            输出: 0
解释: 数组元素个数小于 2，因此返回 0。
说明:
你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。
*/

class Solution {
public:
    int maximumGap(vector<int>& nums) {
        if(nums.size() < 2) return 0;
        int len = nums.size(), minNum = 1e9+7, maxNum = 0, res = 0;
        // 建立三个数组来模拟桶, 数组为len+1, 保证至少有一个桶为空（保证最大差值在桶与桶之间，不在某一个桶内部）
        vector<int> minNums(len+1, 1e9+7);
        vector<int> maxNums(len+1, -1e9+7);
        vector<bool> flag(len+1, false);
        // 先寻找最大值和最小值，确定桶的范围， 然后把数据放入桶中
        for(auto it:nums)minNum = min(minNum, it), maxNum = max(maxNum, it);
        if(maxNum == minNum) return 0;
        
        for(int i=0; i<len; ++i){
            // 当前数应该在几号桶   先乘 可能溢出
            int idx = (double)(nums[i] - minNum) / (maxNum-minNum) * len;
            minNums[idx] = min(minNums[idx], nums[i]);
            maxNums[idx] = max(maxNums[idx], nums[i]);
            flag[idx] = true;
        }
        // 逐个桶进行查找
        minNum = maxNums[0];
        for(int i=1; i<len+1; ++i){
            if(!flag[i])continue;
            res = max(res, minNums[i] - minNum);
            minNum = maxNums[i];
        }
        return res;
    }
};

int main(){
    vector<int> nums({601408776,63967816,431363697,242509930,15970592,60284088,228037800,147629558,220782926,55455864,456541040,106650540,17290078,52153098,103139530,294196042,16568100,426864152,61916064,657788565,166159446,1741650,101791800,28206276,6223796,524849590,125389882,84399672,153834912,164568204,1866165,283209696,560993994,16266096,219635658,9188983,485969304,782013650,120332636,44659356,444517408,36369045,47370708,18542592,98802990,137690000,124889895,56062800,265421676,309417680,4634176,801661539,510541206,258227892,398938089,47255754,152260962,409663140,102847688,45756553,377936600,269498,375738702,263761134,53797945,329493948,224442208,508336845,189507850,40944620,127879560,119629476,186894520,62409156,693721503,4289916,523899936,28955240,266488028,20356650,40769391,483694272,97988044,84102,67246047,310688630,41288643,58965588,42881432,152159462,94786355,174917835,119224652,525034376,261516,274800528,62643819,23613832,8397240,797832131,855155367,337066320,26341480,61932200,20661075,515542796,390337500,522552030,43538516,150800550,116747540,152989123,488640056,700610304,233604,344277340,21439176,9397864,16365822,73027584,453041413,197374275,157735188,15273822,187081152,379611084,865005504,223099767,80478651,377729400,186738219,34738263,16634072,112791343,99631856,119364960,477106486,583953920,624509809,188442472,294181256,213023715,146645884,149530380,497592753,132170327,72770643,126683010,405141255,590214306,26670714,95582385,162080790,231120099,8946432,204967980,592849110,54120698,375915096,602145859,5346440,226337825,425156369,653591624,578483360,572410800,32290700,381384563,149939976,183225375,155695620,38307636,457513760,97085778,75200576,8068176,221650296,556889418,252495726,895020231,19932465,156334887,191383314,348432526,368701264,14315598,148936587,279419435,237325542,252587218,322929504,26331343,355297676,600420786,652017765,51673622,159015675});

    Solution* so = new Solution();
    int num = so->maximumGap(nums);
    cout<<num<<endl;
    return 0;
}